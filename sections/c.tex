\entry{Camera}{
	The Camera represents the player's point of view. 
	how the player sees the world. For this reason, 
	cameras only have relevance to human-controlled 
	players. The \texttt{PlayerController} specifies a 
	camera class and instantiates a Camera Actor \ref{Actor} 
	which is used to calculate the position and orientation 
	the player views the world from.
}

\entry{Canvas}{
	The Canvas is an object that can be used 
	during the render loop of the HUD \ref{HUD} 
	to draw elements - text, texture and material 
	tiles, arbitrary triangles, and simple primitive 
	shapes - to the screen. Unless you are making 
	use of some specialized alternative, 
	drawing with the Canvas is the method used to 
	create HUDs and UIs in games made with Unreal Engine.
}

\entry{Character}{
	A Character is a subclass of a Pawn Actor \ref{Pawn}
	that is intended to be used as a player 
	character. The Character subclass includes 
	a collision setup, input bindings for bipedal 
	movement, and additional code for movement 
	controlled by the player.
}

\entry{Class}{
	A Class defines the behaviors and properties of 
	a particular Actor \ref{Actor} or Object \ref{Object} used in the 
	creation of an Unreal Engine game. Classes 
	are hierarchical, meaning a Class inherits 
	information from its parent Classes 
	(the Classes it was derived or "sub-classed" from) 
	and passes that information to its children. 
	Classes can be created in C++ code or in Blueprints \ref{Blueprint}.
}

\entry{Component}{
	A Component is a piece of functionality that can be 
	added to an Actor \ref{Actor}. Components cannot exist 
	by themselves, however when added to an Actor, 
	the Actor will have access to and can 
	use functionality provided by the Component.

	For example, a Spot Light \ref{Spot light} Component 
	will allow your Actor to emit light \ref{Light} like 
	a spot light, a Rotating Movement Component will make 
	your Actor spin around, or an Audio Component will 
	make your Actor able to play sounds.
}

\entry{Context}{
	Within the Environment Query System (EQS), 
	Contexts provide a frame of reference for 
	any Tests  or Generators \ref{Generator} used. 
	A Context can be as simple as the Querier 
	(who is performing the Test) or more complex 
	such as All Actors of a Type. A Generator, 
	such as a Points: Grid, can use a Context 
	that returns multiple locations or Actors. 
	This will create a grid 
	(of the defined size and density) at the 
	location of each Context. In addition to Engine 
	supplied Contexts, you can create custom Contexts 
	in Blueprint \ref{Blueprint} with the 
	\texttt{EnvQueryContext\_BlueprintBase} class or 
	through C++ code. 
}

\entry{Controller}{
	Controllers are non-physical Actors 
	that can possess a Pawn \ref{Pawn} 
	(or Pawn-derived class like Character) 
	to control its actions. A \texttt{PlayerController} 
	is used by human players to control Pawns, 
	while an \texttt{AIController} implements the 
	artificial intelligence \ref{AI} for the Pawns 
	they control. Controllers take control of 
	a Pawn with the Possess function, 
	and give up control of the Pawn 
	with the Unpossess function.

	Controllers receive notifications 
	for many of the events occurring 
	for the Pawn they are controlling. 
	This gives the Controller the opportunity 
	to implement the behavior in response to 
	this event, intercepting the event and 
	superseding the Pawn's default behavior. 
	It is possible to make the Controller tick 
	before a given Pawn, which minimizes latency 
	between input processing and Pawn movement.
}